# -*- coding: utf-8 -*-
"""Task 1, 12, 13.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Uryuk4-cT1fQ26G218_FevJ7orrwNd5H

# Overview:
## Task 1. Impact of the building's age on the damage grade.

## Task 2. Impact of the land features on the damage grade.

## Task 3. Impact of the structure features on the damage grade.
"""

import sys
import pandas as pd
import csv
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns

# load file 
from google.colab import drive
drive.mount('/content/drive')

input_file = '/content/drive/MyDrive/earthquake/preprocessed_data.csv' 
df = pd.read_csv(input_file)

# check the dataframe
print(df.columns) # check all the features' names
df.head()

"""# Task 1. Study the impact of age on the damage level 
Q1. does an older building always have a more severe damage level?

Step 1. Study the distribution of age of this dataset. Decide how to group the data by age.

Step 2. Group the data by ages and then compute the average damage level within each group. Visualize the data by bar-plot. 

Step 3. Group the data by damage level and plot the histogram of ages. 

"""

from numpy import histogram
# Step 1. .  

# Creating histogram of age
fig, axs = plt.subplots(1, 1,
                        figsize =(15, 7),
                        tight_layout = True) 
n_bins = 100
x = df['age']
# x = df['age_building']
axs.hist(x, bins = n_bins)
plt.show()

"""The age of the building is most concentrated on the range [0, 100]."""

# histogram for data with age <= 100
n_bins = 100
# Creating histogram of age
fig, axs = plt.subplots(1, 1,
                        figsize =(10, 7),
                        tight_layout = True) 
x = df[df['age'] <= 100]["age"]
# x = df[df['age_building'] <= 100]["age_building"]
axs.hist(x, bins = n_bins)
plt.show()

"""## Group based on the age: Convert the numerical feature to a categorical one
Add a new feature that indicates the group of age. For example, if group age is "(0, 10]", it means this building has an age within the range (0, 10].
"""

# add a categorical data that indicates the group of age 
# reference: https://stackoverflow.com/questions/21441259/pandas-groupby-range-of-values
n_bins = 20
# a = np.histogram(df[df['age']<=100]['age'], bins=n_bins)
a = np.histogram(df[df['age']<=100]['age'], bins=n_bins)
bins = list(a[1])
bins += [800, 1000]
# print(bins)
# print(bins[:-1], bins[1:]) 
bins = pd.IntervalIndex.from_arrays(left=bins[:-1], right=bins[1:]) 
# print(bins)
df['age_group'] = pd.cut(df['age'], bins)

# check the result of step 1
df.head()

"""## Study the average damage level within each age bin."""

# Step 2. Compute avg of damage level within each age group 
step2_result = df.groupby("age_group")["damage_grade"].mean()
step2_result

fig = plt.figure()
fig.set_figwidth(10)
fig.set_figheight(4)
ax = fig.add_axes([0,0,1,1])
plt.setp(ax.get_xticklabels(), rotation=30, horizontalalignment='right')
names = step2_result.index.astype(str)   
step2_result2 = [e for e in step2_result] # for boosting the visualization result 
ax.plot(names, step2_result2)

# present the results using box-plot
sns.set(rc={'figure.figsize':(20, 8)}) 
sns.set_style("ticks") 
# group_age = df['age_group'].astype('object')
# ax = sns.stripplot(x='age_group', y='damage_grade', jitter=True, size=6, zorder=0, alpha=0.5, linewidth =1, data=df)
ax = sns.boxplot(x='age_group', y='damage_grade', data=df, palette="Blues")
ax.set_xticklabels(names, rotation=30)
ax.plot(names, step2_result, 'ko-', lw=3)

"""The average damage level is increasing with the building's age. However, this is not the case for building with age between (800, 1000]. We will come back to this later.

## Study how the age is distributed within each group of the same damage level.
"""

# Step 3. Group the data by damage level and plot the histogram of ages. 
fig, axs = plt.subplots(1, 5,
                        figsize =(20, 5),
                        tight_layout = True) 
n_bins = 20
df_clean = df[df['age'] <= 100]
for damage in range(1, 6):
  x = df_clean[df_clean['damage_grade'] == damage]['age']
  print(np.mean(x))
  axs[damage-1].hist(x, bins = n_bins)
  axs[damage-1].set_title("damage level: {}".format(damage))
plt.show()

"""Building with smaller age has less severe damage grade.

# Task 12. Study the impact of Land features (land surface condition)

## Impact of land surface condition on damage level
"""

def label_function(val):
    # return f'{val / 100 * len(df):.0f}\n{val:.0f}%' 
    return f'{val:.0f}%' 

df.groupby('land_surface_condition').size().plot(kind='pie', \
          textprops={'fontsize':15},colors=['tomato', 'gold', 'skyblue'],\
          autopct=label_function, ylabel="")

df['land_surface_condition']

fig = plt.figure()
fig.set_figwidth(4)
fig.set_figheight(4)
ax = fig.add_axes([0,0,1,1])
plt.setp(ax.get_xticklabels(), rotation=30, horizontalalignment='right')
results = df.groupby("land_surface_condition")['damage_grade'].mean()
names = results.index.astype(str)    
ax.bar(names, results)

"""Hardly any differences.

# Task 13. Study the impact of Structure features (count of floor; roof type; ground floor type; foundation type; position of the building;)

## Impact of the foundation type
"""

def label_function(val):
    # return f'{val / 100 * len(df):.0f}\n{val:.0f}%' 
    return f'{val:.0f}%' 

df.groupby('foundation_type').size().plot(kind='pie', \
          textprops={'fontsize':15},colors=['tomato', 'gold', 'skyblue'],\
          autopct=label_function, ylabel="")

fig = plt.figure()
fig.set_figwidth(4)
fig.set_figheight(4)
ax = fig.add_axes([0,0,1,1])
plt.setp(ax.get_xticklabels(), rotation=40, horizontalalignment='right')
results = df.groupby("foundation_type")['damage_grade'].mean()
names = results.index.astype(str)    
ax.bar(names, results)
print(results)

"""As the most commonly used materials, Mud mortar-Stone/Brick behaves poorly in the robustness against earthquake.

## Impact of ground floor type
"""

df['ground_floor_type'].hist(figsize=(5,4))

# def label_function(val):
#     # return f'{val / 100 * len(df):.0f}\n{val:.0f}%' 
#     return f'{val:.0f}%' 

# df.groupby('ground_floor_type').size().plot(kind='pie', \
#           textprops={'fontsize':15},colors=['tomato', 'gold', 'skyblue'],\
#           autopct=label_function, ylabel="", labeldistance=1.1)

"""Most buildings use Mud as the ground floor type. """

fig = plt.figure()
fig.set_figwidth(6)
fig.set_figheight(4)
ax = fig.add_axes([0,0,1,1])
plt.setp(ax.get_xticklabels(), horizontalalignment='right')
results = df.groupby("ground_floor_type")['damage_grade'].mean()
names = results.index.astype(str)    
ax.bar(names, results)
plt.xlabel("ground_floor_type")
plt.ylabel("avg damage grade")
print(results)

"""Buildings using RC as the ground floor material have the smallest average damage grade

## Impact of roof type
"""

def label_function(val):
    # return f'{val / 100 * len(df):.0f}\n{val:.0f}%' 
    return f'{val:.0f}%' 

df.groupby('roof_type').size().plot(kind='pie', \
          textprops={'fontsize':15},colors=['tomato', 'gold', 'skyblue'],\
          autopct=label_function, ylabel="", labeldistance=1.1)

fig = plt.figure()
fig.set_figwidth(4)
fig.set_figheight(4)
ax = fig.add_axes([0,0,1,1])
plt.setp(ax.get_xticklabels(), rotation=30, horizontalalignment='right')
results = df.groupby("roof_type")['damage_grade'].mean()
names = results.index.astype(str)    
ax.bar(names, results)

"""## Impact of position"""

df['position'].hist(figsize=(6,5))

fig = plt.figure()
fig.set_figwidth(5)
fig.set_figheight(4)
ax = fig.add_axes([0,0,1,1])
plt.setp(ax.get_xticklabels(), horizontalalignment='right', rotation=30)  
results = df.groupby('position')['damage_grade'].mean()
names = results.index.astype(str)    
d = ax.bar(names, results)  
plt.ylabel("avg damage level")

"""Buildings that are attached-3 side have the smallest average damage grade. Buildings with less sides attached have larger average damage grade.

## the impact of count of floors
"""

df['count_floors_pre_eq'].hist()

"""Most buildings have less than 4 floors; so we treat buildings with count of floor >= 4 as one group."""

fig = plt.figure()
fig.set_figwidth(6)
fig.set_figheight(4)
ax = fig.add_axes([0,0,1,1])
plt.setp(ax.get_xticklabels(), horizontalalignment='right')
results = df.groupby("count_floors_pre_eq")['damage_grade'].mean()
results[4] = df[df['count_floors_pre_eq'] >= 4]['damage_grade'].mean()
names = results.index.astype(str)    
ax.plot(names[:4], results[:4])
plt.xlabel("count of floors")
plt.ylabel("avg damage level")
plt.xticks(np.arange(4), labels=['1','2','3', '>=4']) 
print(results[:4])

"""For buildings with less than 4 floors, buildings with more floors tend to have higher damage level; but for buildings with more than 4 floors, the average damage grade drops. We explore this in the remaining question section.

# Remaining Question: why is the relation between number of floors and damage grade? 
Quick answer: Group buildings into 2 groups (<=3, >=4); these 2 groups of buildings have different preferences in roof type, ground floor type, foundaion type and position.

## The two groups of buildings have very different damage grade distribution. 
We will explore why in the upcoming sections.
"""

fig, axs = plt.subplots(1, 2,
                        figsize =(12,5),
                        tight_layout = False,)    
# plt.xticks(np.arange(6)) 
x = df[df['count_floors_pre_eq'] <= 3]['damage_grade'] 
d = axs[0].hist(x, bins=5)
axs[0].set_title("count of floors <= 3")
barwidth = d[1][2]-d[1][1] 
axs[0].set_xticks(ticks = d[1]+barwidth/2)
axs[0].set_xticklabels(labels=['1','2','3','4','5'])
axs[0].set_xlim([0.5, 5.5])

x = df[df['count_floors_pre_eq'] >= 4]['damage_grade'] 
axs[1].hist(x, bins=5)
axs[1].set_title("count of floors >= 4")
axs[1].set_xticks(ticks = d[1]+barwidth/2)
axs[1].set_xticklabels(labels=['1','2','3','4','5'])
plt.show()

"""## The two groups of buildings have different preferences for foundation type."""

fig, axs = plt.subplots(1, 2,
                        figsize =(15,5),
                        tight_layout = False,)    
x = df[df['count_floors_pre_eq'] <= 3].groupby("foundation_type")['foundation_type'].count()
axs[0].bar(x.index, x)
axs[0].set_xticklabels(x.index, rotation=30) 
axs[0].set_title("count of floors <= 3")

x = df[df['count_floors_pre_eq'] >= 4].groupby("foundation_type")['foundation_type'].count()
axs[1].bar(x.index, x)
axs[1].set_xticklabels(x.index, rotation=30)
axs[1].set_title("count of floors >= 4")

plt.figure(figsize=(6,6))
x1 = df[df['count_floors_pre_eq'] <= 3].groupby("foundation_type")['foundation_type'].count()
x2 = df[df['count_floors_pre_eq'] >= 4].groupby("foundation_type")['foundation_type'].count()
d1 = []
for i in range(len(x1)):
  d1.append(x1[i]/sum(x1))
d2 = []
for i in range(len(x2)):
  d2.append(x2[i]/sum(x2)) 

X = x1.index
X_axis = np.arange(len(X))
plt.bar(X_axis - 0.2, d1, 0.4, label = '<= 3')
plt.bar(X_axis + 0.2, d2, 0.4, label = '>= 4')
plt.xticks(X_axis, X, rotation=30)
# plt.xlabel("foundation type")
plt.ylabel("portion of buildings")
plt.legend()

"""## The two groups of buildings have different preferences for ground floor type."""

fig, axs = plt.subplots(1, 2,
                        figsize =(15,5),
                        tight_layout = False,)    
x = df[df['count_floors_pre_eq'] <= 3].groupby("ground_floor_type")['ground_floor_type'].count()
axs[0].bar(x.index, x)
axs[0].set_xticklabels(x.index, rotation=30) 
axs[0].set_title("count of floors <= 3")

x = df[df['count_floors_pre_eq'] >= 4].groupby("ground_floor_type")['ground_floor_type'].count()
axs[1].bar(x.index, x)
axs[1].set_xticklabels(x.index, rotation=30)
axs[1].set_title("count of floors >= 4")

plt.figure(figsize=(6,6))
x1 = df[df['count_floors_pre_eq'] <= 3].groupby("ground_floor_type")['ground_floor_type'].count()
x2 = df[df['count_floors_pre_eq'] >= 4].groupby("ground_floor_type")['ground_floor_type'].count()
d1 = []
for i in range(len(x1)):
  d1.append(x1[i]/sum(x1))
d2 = []
for i in range(len(x2)):
  d2.append(x2[i]/sum(x2)) 

X = x1.index
X_axis = np.arange(len(X))
plt.bar(X_axis - 0.2, d1, 0.4, label = '<= 3')
plt.bar(X_axis + 0.2, d2, 0.4, label = '>= 4')
plt.xticks(X_axis, X)
plt.xlabel("ground floor type")
plt.ylabel("portion of buildings")
plt.legend()

"""## The two groups of buildings have different preferences for roof type."""

fig, axs = plt.subplots(1, 2,
                        figsize =(20,5),
                        tight_layout = False,)    
x = df[df['count_floors_pre_eq'] <= 3].groupby("roof_type")['roof_type'].count()
axs[0].bar(x.index, x)
axs[0].set_xticklabels(x.index, rotation=30) 
axs[0].set_title("count of floors <= 3")

x = df[df['count_floors_pre_eq'] >= 4].groupby("roof_type")['roof_type'].count()
axs[1].bar(x.index, x)
axs[1].set_xticklabels(x.index, rotation=30)
axs[1].set_title("count of floors >= 4")

plt.figure(figsize=(6,6))
x1 = df[df['count_floors_pre_eq'] <= 3].groupby("roof_type")['roof_type'].count()
x2 = df[df['count_floors_pre_eq'] >= 4].groupby("roof_type")['roof_type'].count()
d1 = []
for i in range(len(x1)):
  d1.append(x1[i]/sum(x1))
d2 = []
for i in range(len(x2)):
  d2.append(x2[i]/sum(x2)) 

X = x1.index
X_axis = np.arange(len(X))
plt.bar(X_axis - 0.2, d1, 0.4, label = '<= 3')
plt.bar(X_axis + 0.2, d2, 0.4, label = '>= 4')
plt.xticks(X_axis, X, rotation=15)
# plt.xlabel("roof_type")
plt.ylabel("portion of buildings")
plt.legend()

"""## The two groups of buildings have different distributions of position(i.e. number of sides attached to other buildings)"""

fig, axs = plt.subplots(1, 2,
                        figsize =(20,5),
                        tight_layout = False,)    
x = df[df['count_floors_pre_eq'] <= 3].groupby("position")['position'].count()
axs[0].bar(x.index, x)
axs[0].set_xticklabels(x.index, rotation=30) 
axs[0].set_title("count of floors <= 3")

x = df[df['count_floors_pre_eq'] >= 4].groupby("position")['position'].count()
axs[1].bar(x.index, x)
axs[1].set_xticklabels(x.index, rotation=30)
axs[1].set_title("count of floors >= 4")

plt.figure(figsize=(6,6))
x1 = df[df['count_floors_pre_eq'] <= 3].groupby("position")['position'].count()
x2 = df[df['count_floors_pre_eq'] >= 4].groupby("position")['position'].count()
d1 = []
for i in range(len(x1)):
  d1.append(x1[i]/sum(x1))
d2 = []
for i in range(len(x2)):
  d2.append(x2[i]/sum(x2)) 

X = x1.index
X_axis = np.arange(len(X))
plt.bar(X_axis - 0.2, d1, 0.4, label = '<= 3')
plt.bar(X_axis + 0.2, d2, 0.4, label = '>= 4')
plt.xticks(X_axis, X, rotation=15)
# plt.xlabel("position")
plt.ylabel("portion of buildings")
plt.legend()

"""## Revisiting count_of_floors: 
What we observe previously about the relationship between number of floors and damage grade might not be true. We need to fix other structure features (foundation type, ground floor type, roof type, and position) to give a closer look on how the number of floors alone impacts the damage grade.
"""

# creating a dataset with fixed structure features (expect the number of floors)
df_bricks = df.copy()
df_bricks = df_bricks[df_bricks['foundation_type']== "Mud mortar-Stone/Brick"] 
df_bricks = df_bricks[df_bricks['ground_floor_type']== "Mud"]  
df_bricks = df_bricks[df_bricks['roof_type'] == 'Bamboo/Timber-Heavy roof'] 
df_bricks = df_bricks[df_bricks['position']=="Not attached"]
print(df_bricks.shape)

## comparison method 1
fig, axs = plt.subplots(1, 2,
                        figsize =(20,5),
                        tight_layout = False,)     
# first plot
results = df_bricks.groupby("count_floors_pre_eq")['damage_grade'].mean()
names = results.index.astype(str)    
results[4] = df_bricks[df_bricks['count_floors_pre_eq'] >= 4]['damage_grade'].mean()
axs[0].bar(names[:4], results[:4])
axs[0].set_xlabel("count of floors")
axs[0].set_ylabel("avg damage level")
axs[0].set_xticklabels(labels=['1','2','3', '>=4']) 

# second plot
results = df.groupby("count_floors_pre_eq")['damage_grade'].mean()
names = results.index.astype(str)    
results[4] = df[df['count_floors_pre_eq'] >= 4]['damage_grade'].mean()
axs[1].bar(names[:4], results[:4])
axs[1].set_xlabel("count of floors")
axs[1].set_ylabel("avg damage level")
axs[1].set_xticklabels(labels=['1','2','3', '>=4'])

## comparison method 2
fig, axs = plt.subplots(1, 1,
                        figsize =(6,5),
                        tight_layout = False,)     
# first plot
results = df_bricks.groupby("count_floors_pre_eq")['damage_grade'].mean()
names = results.index.astype(str)    
results[4] = df_bricks[df_bricks['count_floors_pre_eq'] >= 4]['damage_grade'].mean()
axs.plot(names[:4], results[:4])
axs.set_xlabel("count of floors")
axs.set_ylabel("avg damage level")
axs.set_ylim([1, 5])
axs.set_xticklabels(labels=['1','2','3', '>=4']) 

# second plot
results = df.groupby("count_floors_pre_eq")['damage_grade'].mean()
names = results.index.astype(str)    
results[4] = df[df['count_floors_pre_eq'] >= 4]['damage_grade'].mean()
axs.plot(names[:4], results[:4])

## comparison method 3
fig, axs = plt.subplots(1, 2,
                        figsize =(13,5),
                        tight_layout = False,)  
## first plot
x1 = df[df['count_floors_pre_eq'] <= 3].groupby("damage_grade")['damage_grade'].count()
x2 = df[df['count_floors_pre_eq'] >= 4].groupby("damage_grade")['damage_grade'].count()
# print(x1, x2)
# print(sum(x1),sum(x2))
d1 = []
for i in range(1,len(x1)+1):
  d1.append(x1[i]/sum(x1)) 
d2 = []
for i in range(1,len(x2)+1):
  d2.append(x2[i]/sum(x2))  
X = x1.index 
X_axis = np.arange(len(X))
axs[0].bar(X_axis - 0.2, d1, 0.4, label = '<= 3')
axs[0].bar(X_axis + 0.2, d2, 0.4, label = '>= 4')
axs[0].set_xticks(X_axis)
axs[0].set_xticklabels(X, rotation=0)
# plt.xlabel("foundation type")
axs[0].set_ylabel("portion of buildings")
axs[0].legend(loc='upper right') 

## second plot
x1 = df_bricks[df_bricks['count_floors_pre_eq'] <= 3].groupby("damage_grade")['damage_grade'].count()
x2 = df_bricks[df_bricks['count_floors_pre_eq'] >= 4].groupby("damage_grade")['damage_grade'].count()
# print(x1, x2)
# print(sum(x1),sum(x2))
d1 = []
for i in range(1,len(x1)+1):
  d1.append(x1[i]/sum(x1)) 
d2 = []
for i in range(1,len(x2)+1):
  d2.append(x2[i]/sum(x2))  
X = x1.index 
X_axis = np.arange(len(X))
axs[1].bar(X_axis - 0.2, d1, 0.4, label = '<= 3')
axs[1].bar(X_axis + 0.2, d2, 0.4, label = '>= 4')
axs[1].set_xticks(X_axis)
axs[1].set_xticklabels(X, rotation=0)
# plt.xlabel("foundation type")
axs[1].set_ylabel("portion of buildings")
axs[1].legend(loc='upper right')

"""For buildings with equal foundation type, ground floor type, roof type and position, the count of floors does not have a great impact on the average damage level."""
